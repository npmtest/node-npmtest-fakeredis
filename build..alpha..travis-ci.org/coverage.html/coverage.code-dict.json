{"/home/travis/build/npmtest/node-npmtest-fakeredis/test.js":"/* istanbul instrument in package npmtest_fakeredis */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-fakeredis/lib.npmtest_fakeredis.js":"/* istanbul instrument in package npmtest_fakeredis */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_fakeredis = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_fakeredis = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-fakeredis/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-fakeredis && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_fakeredis */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_fakeredis\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_fakeredis.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_fakeredis.rollup.js'] =\n            local.assetsDict['/assets.npmtest_fakeredis.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_fakeredis.__dirname + '/lib.npmtest_fakeredis.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-fakeredis/node_modules/fakeredis/main.js":"\"use strict\";\n\n// By default fakeredis simulates a ridiculous amount of network latency\n// to help you discover race-conditions when testing multi-client setups.\n// Instantiate your 'clients' with a truthy .fast option,\n// or set it here globally to make things go a bit faster.\n\nexports.fast = false;\n\nvar index = require(\"redis\")\n  , Backend = require(\"./lib/backend\").Backend\n  , Connection = require(\"./lib/connection\").Connection\n  , helpers = require(\"./lib/helpers\")\n\n  , backends = {}\n  , RedisClient = index.RedisClient\n\n  , anon = 0;\n\n\n// Re-export redis exports.\n\nexports.RedisClient = index.RedisClient;\nexports.Multi = index.Multi;\nexports.print = index.print;\nexports.backends = backends;\n\n// Overriden client factory.\n\nexports.createClient = function(port, host, options) {\n  if (arguments.length == 1 && typeof port == \"object\") { \n    options = port;\n    if (options.port || options.host) {\n      port = options.port;\n      host = options.host;\n    }\n    if (options.url || options.path) { \n      host = options.url || options.path;\n      port = \"\";\n    }\n  }\n  var id = !port && !host ? 'fake_' + (++anon) : (host || \"\") + ((port) ? \":\" + port : null || \"\")\n    , lat = options && options.fast || exports.fast ? 1 : null\n    , c = new Connection(backends[id] || (backends[id] = new Backend), lat, lat)\n    , real_create_stream = RedisClient.prototype.create_stream\n    , returnBuffers = options && options.return_buffers\n    , detectBuffers = options && options.detect_buffers;\n\n  // Mock create_stream to create a new RedisClient without creating a socket\n  RedisClient.prototype.create_stream = function () {\n    this.connected = true;\n    this.ready = true;\n  };\n\n  var cl = new RedisClient(/* options */)\n\n  // Replace the mocked create_stream function again with the original one\n  RedisClient.prototype.create_stream = real_create_stream;\n\n  if (options && options.verbose)\n    c.verbose = true;\n\n  cl.end = function() {\n    cl.send_command = function(command) {\n      throw new Error(\"fakeredis: You've closed this connection with .end(), cannot \" + command);\n    };\n  };\n\n  cl.send_command = function(command, args, callback) {\n\n    // Interpret arguments, copy-paste from mranney/redis/index.js for best compat.\n    if (typeof command !== \"string\") {\n      throw new Error(\"First argument to send_command must be the command name string, not \" + typeof command);\n    }\n\n    if (Array.isArray(args)) {\n      if (typeof callback === \"function\") {\n        // probably the fastest way:\n        //     client.command([arg1, arg2], cb);  (straight passthrough)\n        //         send_command(command, [arg1, arg2], cb);\n      } else if (! callback) {\n        // most people find this variable argument length form more convenient, but it uses arguments, which is slower\n        //     client.command(arg1, arg2, cb);   (wraps up arguments into an array)\n        //       send_command(command, [arg1, arg2, cb]);\n        //     client.command(arg1, arg2);   (callback is optional)\n        //       send_command(command, [arg1, arg2]);\n        //     client.command(arg1, arg2, undefined);   (callback is undefined)\n        //       send_command(command, [arg1, arg2, undefined]);\n        var last_arg_type = typeof args[args.length - 1];\n        if (last_arg_type === \"function\" || last_arg_type === \"undefined\") {\n          callback = args.pop();\n        }\n      } else {\n        throw new Error(\"send_command: last argument must be a callback or undefined\");\n      }\n    } else {\n      throw new Error(\"send_command: second argument must be an array\");\n    }\n\n    // if the last argument is an array, expand it out.  This allows commands like this:\n    //     client.command(arg1, [arg2, arg3, arg4], cb);\n    //  and converts to:\n    //     client.command(arg1, arg2, arg3, arg4, cb);\n    // which is convenient for some things like sadd\n    if (Array.isArray(args[args.length - 1])) {\n      args = args.slice(0, - 1).concat(args[args.length - 1]);\n    }\n\n\n    // Arg check.\n\n    var useBuffers = returnBuffers;\n    var i, n;\n    n = args.length;\n    for (i = 0; i < n; i++) {\n      var arg = args[i];\n\n      // buf support\n      if (Buffer.isBuffer(arg)) {\n        args[i] = packageBuffer(arg);\n        if (detectBuffers)\n          useBuffers = true;\n      }\n\n      // lint\n      else if (typeof arg !== 'string' && typeof arg !== 'number') {\n        var err = new Error(\"fakeredis/lint: Argument #\" + i + \" for \" + command + \" is not a String, Buffer or Number: \" + arg);\n        if (callback)\n          return callback(err);\n        else\n          throw err;\n      }\n    }\n\n\n    // Callback middleware.\n\n    if (callback) {\n\n      // hgetall sugar\n      if (/^hgetall/i.test(command))\n        callback = makeReplyToObjectAdaptor(callback);\n\n      // buffer support\n      callback = makeUnpackageBuffersAdaptor(useBuffers, callback);\n    }\n\n\n    //\n\n    c.push(this, command, args, callback);\n  };\n\n  cl.pushMessage = cl.emit.bind(cl);\n\n  (function() {\n    var prop;\n    for (prop in helpers)\n      cl[prop] = helpers[prop];\n  }\n  ());\n\n\n  // Schedule some events.\n\n  process.nextTick(function() {\n    cl.ready = true;\n    cl.emit('ready');\n  });\n\n\n  //\n  return cl;\n};\n\n\n//\n\nfunction makeReplyToObjectAdaptor(callback) {\n  return function(err, data) {\n    if (!err && data)\n      data = reply_to_object(data);\n\n    callback(err, data);\n  };\n}\n\nfunction makeUnpackageBuffersAdaptor(returnAsBuffers, callback) {\n  return function(err, data) {\n    if (!err)\n      data = returnAsBuffers\n        ? unpackageBuffersAsObjects(data)\n        : unpackageBuffersAsStrings(data);\n\n    callback(err, data);\n  };\n}\n\n\n// Helpers for node_redis compat.\n\n// hgetall converts its replies to an Object.  If the reply is empty, null is returned.\nfunction reply_to_object(reply) {\n  var obj = {}, j, jl, key, val;\n\n  if (reply.length === 0) {\n    return null;\n  }\n\n  for (j = 0, jl = reply.length; j < jl; j += 2) {\n    key = reply[j].toString();\n    val = reply[j + 1];\n    obj[key] = val;\n  }\n\n  return obj;\n}\n\n\n// I realize this is possibly the most idiotic way to add support for buffers.\n\nvar BUFFER_PREFIX = \"\\t!bUF?!1\\t\";\n\nfunction packageBuffer(buf) {\n\n  // If possible, try storing the buffer as a utf8 string.\n  // For this to work baking the string back to a buffer must yield the exact same bytes.\n  var asString = buf.toString('utf8');\n  var enc = new Buffer(asString, 'utf8');\n  var n = enc.length;\n  if (n === buf.length) {\n    var ok = true;\n    while (n--)\n      if (buf[n] !== enc[n]) {\n        ok = false;\n        break;\n      }\n\n    if (ok)\n      return asString;\n  }\n\n  // If not possible, keep the buffer as a prefixed, base64 encoded string internally.\n  return BUFFER_PREFIX + buf.toString('base64');\n}\n\nfunction unpackageBuffersAsObjects(data) {\n  if (Array.isArray(data))\n    return data.map(unpackageBuffersAsObjects);\n\n  if (typeof data === 'string' && data.indexOf(BUFFER_PREFIX) === 0)\n    return new Buffer(data.substr(BUFFER_PREFIX.length), 'base64');\n  else if (data)\n    return new Buffer(data.toString(), 'utf8');\n  else\n    return null;\n}\n\nfunction unpackageBuffersAsStrings(data) {\n  if (Array.isArray(data))\n    return data.map(unpackageBuffersAsStrings);\n\n  if (typeof data === 'string' && data.indexOf(BUFFER_PREFIX) === 0)\n    return new Buffer(data.substr(BUFFER_PREFIX.length), 'base64').toString('utf8');\n  else\n    return data;\n}\n\n","/home/travis/build/npmtest/node-npmtest-fakeredis/node_modules/fakeredis/lib/backend.js":"\"use strict\";\n\n\n// Error replies.\n\nvar ERROR = function (message) {\n  this.getError = function () { return message; };\n  this.toString = function () { return \"<ERROR<\" + message + \">>\"; };\n};\n\nvar BAD_TYPE = new ERROR('Operation against a key holding the wrong kind of value');\nvar BAD_KEY = new ERROR('no such key');\nvar BAD_INT = new ERROR('value is not an integer or out of range');\nvar BAD_FLOAT = new ERROR('value is not a valid float');\nvar BAD_ARGS = new ERROR('wrong number of arguments');\nvar BAD_SYNTAX = new ERROR('syntax error');\nvar BAD_INDEX = new ERROR('index out of range');\nvar BAD_SORT = new ERROR('One or more scores can\\'t be converted into double');\n\nvar BAD_BIT1 = new ERROR('bit offset is not an integer or out of range');\nvar BAD_BIT2 = new ERROR('bit is not an integer or out of range');\nvar BAD_SETEX = new ERROR('invalid expire time in SETEX');\nvar BAD_ZUIS = new ERROR('at least 1 input key is needed for ZUNIONSTORE/ZINTERSTORE');\n\n\n// Status replies.\n\nvar STATUS = function (message) {\n  this.getStatus = function () { return message; };\n  this.toString = function () { return \"<STATUS<\" + message + \">>\"; };\n};\n\nvar OK = new STATUS('OK');\nvar PONG = new STATUS('PONG');\nvar NONE = new STATUS('none');\n\n\n// Redis types.\n\nvar VALID_TYPE = function () {};\nvar TYPE = function (type, makePrimitive) {\n  var Constr = function (value) {\n    if (!(this instanceof VALID_TYPE))\n      return new Constr(value);\n    if (!value)\n      value = makePrimitive();\n\n    this.value = value;\n  };\n\n  Constr.getStatus = function () { return type; };\n  Constr.prototype = new VALID_TYPE;\n  Constr.prototype.toString = function () { return \"<TYPE<\" + type + \">>\"; };\n  Constr.prototype.TYPE = Constr;\n  return Constr;\n};\n\nvar EMPTY_STR = { toString: function () { return \"\"; }, length: 0, copy: function () {} };\nvar STRING = TYPE(\"string\", function () { return EMPTY_STR; });\nvar LIST = TYPE(\"list\", function () { return []; });\nvar HASH = TYPE(\"hash\", function () { return {}; });\nvar SET = TYPE(\"set\",  function () { return {}; });\nvar ZSET = TYPE(\"zset\", function () { return {}; });\n\n\n// Utils.\n\nvar arr = function (obj) {\n  var i, n = obj.length, out = [];\n  for (i = 0; i < n; i++)\n    out[i] = obj[i];\n\n  return out;\n};\n\nvar range = function (min, max) {\n  var xlo, xhi;\n\n  if ((xlo = min.substr(0, 1) === '('))\n    min = str2float(min.substr(1));\n  else\n    min = str2float(min);\n\n  if (min instanceof ERROR)\n    return min;\n\n  if ((xhi = max.substr(0, 1) === '('))\n    max = str2float(max.substr(1));\n  else\n    max = str2float(max);\n\n  if (max instanceof ERROR)\n    return max;\n\n  return function (num) {\n    return !((xlo && num <= min) || (num < min) || (xhi && num >= max) || (num > max));\n  };\n};\n\nvar slice = function (arr, start, stop, asCount) {\n  start = str2int(start);\n  stop = str2int(stop);\n  if (start instanceof ERROR) return start;\n  if (stop instanceof ERROR) return stop;\n\n  if (arr.slice) {\n    var n = arr.length;\n    if (asCount) {\n      if (start < 0) {\n        start = 0; // Redis is inconsistent about this, ZRANGEBYSCORE will return an empty multibulk on negative offset\n        stop = 0; // whilst SORT will return as if the offset was 0. Best to lint these away with client-side errors.\n      }\n      else if (stop < 0) stop = n;\n      else stop += start;\n    }\n    else {\n      if (start < 0) start = n + start;\n      if (stop < 0) stop = n + stop;\n      stop++;\n    }\n\n    if (start >= stop)\n      return [];\n    else\n      return arr.slice(start < 0 ? 0 : start, stop > n ? n : stop);\n  }\n\n  else\n    return arr;\n};\n\nvar str2float = function (string) {\n  var value = Number(string);\n  if (typeof string !== 'string') throw new Error(\"WOOT! str2float: '\" + string + \"' not a string.\");\n  if (string === '+inf') value = Number.POSITIVE_INFINITY;\n  else if (string === '-inf') value = Number.NEGATIVE_INFINITY;\n  else if (!string || (!value && value !== 0)) return BAD_FLOAT;\n  return value;\n};\n\nvar str2int = function (string) {\n  var value = str2float(string);\n  if (value instanceof ERROR || value % 1 !== 0) return BAD_INT;\n  return value;\n};\n\nvar pattern = function (string) {\n  string = string.replace(/([+{($^|.\\\\])/g, '\\\\' + '$1');\n  string = string.replace(/(^|[^\\\\])([*?])/g, '$1.$2');\n  string = '^' + string + '$';\n\n  var pattern = new RegExp(string);\n  return pattern.test.bind(pattern);\n};\n\nvar populationCount = function (data) {\n  var count;\n  for (count = 0; data > 0; count++) {\n    data &= data - 1;\n  }\n  return count;\n};\n\n// Keyspace and pubsub.\n\nexports.Backend = function () {\n  var state\n    , dbs = {}\n    , delrev = {}\n    , rev = 0\n\n    , subs = []\n    , call = []\n    , tick = false\n    , nextTick = function () {\n      var c, func;\n      tick = false;\n      c = call.splice(0, call.length);\n      while ((func = c.shift())) func();\n    };\n\n\n  // Select.\n  // Selected keyspace is NOT relevant to pubsub.\n  this.selectDB = function (id) {\n    if (typeof id !== \"number\" || id % 1 !== 0)\n      throw new Error(\"Invalid database id: \" + id);\n\n    // Select or instantiate.\n    var db = dbs[id] || (dbs[id] = {});\n    state = db;\n  };\n\n  // Connections start in database 0.\n  this.selectDB(0);\n\n\n  // Typed getKey.\n\n  this.getKey = function (Type, key, make) {\n    var entry = state[key];\n\n    if (Type && !Type.getStatus)\n      throw new Error(\"WOOT! Type param for getKey is not a valid Type.\");\n    if (key === undefined)\n      throw new Error(\"WOOT! key param for getKey is undefined.\");\n\n    if (entry) {\n      if (entry.expire < Date.now()) {\n        delete state[key];\n        delrev[key] = ++rev;\n        entry = null;\n      }\n      else if (!(entry.value instanceof VALID_TYPE))\n        throw new Error(\"WOOT! keyspace entry value is not a valid Type.\");\n    }\n\n    if (Type) {\n      if (entry && !(entry.value instanceof Type))\n        return BAD_TYPE;\n      if (!entry && make)\n        return new Type;\n    }\n\n    return (entry && entry.value) || null;\n  };\n\n  this.setKey = function (key, value) {\n    if (value) {\n      if (!(value instanceof VALID_TYPE))\n        throw new Error(\"WOOT! Value doesn't have a valid type.\");\n\n      rev++;\n      state[key] = { value: value };\n      state[key].rev = rev;\n      delete delrev[key];\n\n      this.pub(this.UPDATE, key);\n\n      return 1;\n    }\n\n    else if (state[key]) {\n      rev++;\n      delrev[key] = rev;\n      delete state[key];\n\n      return 1;\n    }\n\n    return 0;\n  };\n\n  this.upsetKey = function (key, value) {\n    if (!value)\n      throw new Error(\"WOOT! Update key with a falsy value.\");\n    if (!(value instanceof VALID_TYPE))\n      throw new Error(\"WOOT! Value doesn't have a valid type.\");\n\n    if (state[key] && state[key].expire >= Date.now()) {\n      if (state[key].value !== value)\n        throw new Error(\"WOOT! Chaning value containers during upsetKey.\");\n\n      rev++;\n      state[key].value = value;\n      state[key].rev = rev;\n\n      this.pub(this.UPDATE, key);\n    }\n\n    else\n      this.setKey(key, value);\n  };\n\n  this.getExpire = function (key) {\n    var entry = state[key];\n\n    if (!entry || entry.expire < Date.now()) {\n      delete state[key];\n      return null;\n    }\n\n    return entry.expire;\n  };\n\n  this.setExpire = function (key, expire) {\n    var entry = state[key];\n\n    if (!entry || entry.expire < Date.now()) {\n      delete state[key];\n      return 0;\n    }\n\n    else if (expire) {\n      entry.expire = expire;\n      return 1;\n    }\n\n    else if (entry.expire) {\n      delete entry.expire;\n      return 1;\n    }\n\n    return 0;\n  };\n\n  this.getKeys = function () {\n    var keys = []\n      , key;\n\n    for (key in state)\n      if (this.getKey(null, key))\n        keys.push(key);\n\n    return keys;\n  };\n\n  this.renameKey = function (keyA, keyB) {\n    if (!this.getKey(null, keyA))\n      return false;\n\n    rev++;\n    state[keyB] = state[keyA];\n    state[keyB].rev = rev++;\n    delete state[keyA];\n\n    this.pub(this.UPDATE, keyB);\n\n    return true;\n  };\n\n\n  // Keyspace change event.\n\n  this.UPDATE = new STATUS(\"Key value updated.\");\n\n\n  // For implementing watch and stuff.\n\n  this.getRevision = function (key) {\n    this.getKey(null, key);\n    return (state[key] && state[key].rev) || delrev[key] || 0;\n  };\n\n\n  // Publish / subscribe backend.\n\n  this.pub = function (channel, message) {\n    if (!channel && channel !== '') throw new Error(\"WOOT! Publishing to a falsy, non-string channel : [\" + channel + '] ' + message);\n    if (!message && message !== '') throw new Error(\"WOOT! Publishing a falsy, non-string message : [\" + channel + '] ' + message);\n\n    var i, n = subs.length, sub, x = 0;\n    for (i = 0; i < n; i++) {\n      sub = subs[i];\n\n      if (sub.channel === channel || (sub.pattern !== null && sub.channel(channel))) {\n        if (sub.pattern !== null)\n          call.push(sub.client.pushMessage.bind(sub.client, 'pmessage', sub.pattern, channel, message));\n        else\n          call.push(sub.client.pushMessage.bind(sub.client, 'message', channel, message));\n\n        x++;\n        if (!tick) {\n          tick = true;\n          process.nextTick(nextTick);\n        }\n      }\n    }\n\n    return x;\n  };\n\n  // p - true/false\n  // channel - string\n  // client { push ( pattern, channel, message ) }\n\n  this.sub = function (p, channel, client) {\n    if (!channel && channel !== '') throw new Error(\"WOOT! Subscribing to a falsy, non-string channel : [\" + channel + ']');\n    if (!client || !client.pushMessage) throw new Error(\"WOOT! Subscribing an invalid client : \" + client);\n    if (typeof channel === 'function') throw new Error(\"WOOT! Subscribing to a function : \" + channel);\n\n    var i, n = subs.length, sub, found = false;\n    for (i = 0; i < n; i++) {\n      sub = subs[i];\n      if (sub.client === client && ((p && sub.pattern === channel) || (!p && sub.channel === channel))) {\n        found = true;\n        break;\n      }\n    }\n\n    var x = this.numSubs(client);\n\n    if (!found) {\n      x++;\n\n      subs.push({ pattern: p ? channel : null, channel: p ? pattern(channel) : channel, client: client });\n      process.nextTick(client.pushMessage.bind(client, p ? 'psubscribe' : 'subscribe', channel, x));\n    }\n\n    return x;\n  };\n\n  this.unsub = function (p, channel, client) {\n    if (!channel && channel !== '' && channel !== null) throw new Error(\"WOOT! Unsubscribing from a falsy, non-string, non-null channel : [\" + channel + ']');\n    if (!client || !client.pushMessage) throw new Error(\"WOOT! Unsubscribing an invalid client : \" + client);\n\n    var x = this.numSubs(client);\n\n    var i, n = subs.length, sub;\n    for (i = 0; i < n; i++) {\n      sub = subs[i];\n      if (sub.client !== client)\n        continue;\n\n      if ((p && sub.pattern !== null && (channel === null || sub.pattern === channel)) || (!p && sub.pattern === null && (channel === null || sub.channel === channel))) {\n        x--;\n        subs.splice(i, 1);\n        process.nextTick(client.pushMessage.bind(client, p ? 'punsubscribe' : 'unsubscribe', p ? sub.pattern : sub.channel, x));\n        i--; n--;\n      }\n    }\n\n    return x;\n  };\n\n  this.numSubs = function (client) {\n    var i, n = subs.length, x = 0;\n    for (i = 0; i < n; i++)\n      if (subs[i].client === client)\n        x++;\n\n    return x;\n  };\n\n};\n\n\n// Redis commands.\n\nexports.Backend.prototype = {\n\n\n  // Keys.\n\n  DEL: function () {\n    var i, n = arguments.length, x = 0;\n    if (!n) return BAD_ARGS;\n    for (i = 0; i < n; i++)\n      if (this.setKey(arguments[i], null)) x++;\n\n    return x;\n  }\n\n, EXISTS: function (key) {\n    return this.getKey(null, key)? 1 : 0;\n  }\n\n, PEXPIREAT: function (key, time) {\n    time = str2int(time);\n    if (time instanceof ERROR) return time;\n    return this.setExpire(key, time);\n  }\n\n, EXPIREAT: function (key, time) {\n    time = str2int(time);\n    if (time instanceof ERROR) return time;\n    return this.setExpire(key, time * 1000);\n  }\n\n, PEXPIRE: function (key, time) {\n    time = str2int(time);\n    if (time instanceof ERROR) return time;\n    return this.setExpire(key, time + Date.now());\n  }\n\n, EXPIRE: function (key, time) {\n    time = str2int(time);\n    if (time instanceof ERROR) return time;\n    return this.setExpire(key, time * 1000 + Date.now());\n  }\n\n, PERSIST: function (key) {\n    return this.PEXPIREAT(key, \"0\");\n  }\n\n, PTTL: function (key) {\n    var ttl = this.getExpire(key);\n    if (ttl) return ttl - Date.now();\n    else return - 1;\n  }\n\n, RANDOMKEY: function () {\n    var keys = this.getKeys(), n = keys && keys.length;\n    if (n) return keys[Math.floor(Math.random()* n)];\n    else return null;\n  }\n\n, RENAME: function (key, newkey) {\n    return this.renameKey(key, newkey)? OK : BAD_KEY;\n  }\n\n, RENAMENX: function (key, newkey) {\n    if (!this.EXISTS(key)) return BAD_KEY;\n    if (this.EXISTS(newkey)) return 0;\n    if (!this.renameKey(key, newkey)) throw new Error(\"WOOT! Couldn't rename.\");\n    return 1;\n  }\n\n, TTL: function (key) {\n    var ttl = this.getExpire(key);\n    if (ttl) return Math.ceil((ttl - Date.now())/ 1000);\n    else return - 1;\n  }\n\n, TYPE: function (key) {\n    var K = this.getKey(null, key);\n    return K ? K.TYPE : NONE;\n  }\n\n, KEYS: function (pat) {\n    var keys = this.getKeys().filter(pattern(pat));\n    keys.sort();\n    return keys;\n  }\n\n, SCAN: function () {\n    return this._scan(this.getKeys(), 1, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);\n  }\n\n, SSCAN: function () {\n    return this._scan(this.SMEMBERS(arguments[0]), 1, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n  }\n\n, HSCAN: function () {\n    return this._scan(this.HGETALL(arguments[0]), 2, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n  }\n\n, ZSCAN: function () {\n    return this._scan(this.ZRANGE(arguments[0], '0', '-1', 'WITHSCORES'), 2, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n  }\n\n, _scan: function (allKeys, size, cursor, opt1, opt1val, opt2, opt2val) {\n    cursor = str2int(cursor);\n    if (cursor instanceof ERROR)\n      return cursor;\n\n    var count = 10;\n    var matchPattern = null;\n\n    opt1 = (opt1 || '').toUpperCase();\n    opt2 = (opt2 || '').toUpperCase();\n    if (opt1 === 'MATCH') {\n      matchPattern = pattern(opt1val);\n      if (opt2 === 'COUNT')\n        count = str2int(opt2val);\n      else if (opt2)\n        return BAD_SYNTAX;\n    }\n    else if (opt1 === 'COUNT') {\n      if (opt2)\n        return BAD_SYNTAX;\n      else\n        count = str2int(opt1val);\n    }\n    else if (opt1)\n      return BAD_SYNTAX;\n\n    if (count instanceof ERROR)\n      return count;\n\n    var nextCursor = cursor + count;\n    var keys = allKeys.slice(cursor, nextCursor);\n\n    // Apply MATCH filtering _after_ getting number of keys\n    if (matchPattern) {\n      var i = 0;\n      while (i < keys.length)\n        if (!matchPattern(keys[i]))\n          keys.splice(i, size);\n        else\n          i += size;\n    }\n\n    // Return 0 when iteration is complete.\n    if (nextCursor >= allKeys.length)\n      nextCursor = 0;\n\n    return [nextCursor, keys];\n  }\n\n\n  // String setters.\n\n, SET: function () {\n    if (arguments.length < 2) return BAD_ARGS;\n    var argc = 0;\n    var key = arguments[argc++];\n    var value = arguments[argc++];\n    var buf = new Buffer(Buffer.byteLength(value));\n      buf.write(value);\n\n    var optNX = false;\n    var optXX = false;\n    var optEX = 0;\n    var optPX = 0;\n\n    // process.stdout.write('arguments is ' + JSON.stringify(arguments));\n    while (argc < arguments.length) {\n      switch (arguments[argc++].toUpperCase()) {\n        case 'NX': {\n          optNX = true;\n          break;\n        }\n        case 'XX': {\n          optXX = true;\n          break;\n        }\n        case 'EX': {\n          if (arguments.length === argc)\n            return BAD_ARGS;\n          optEX = arguments[argc++];\n          /*jshint -W018*/\n          if (!(str2int(optEX) > 0))\n            return BAD_INT;\n          break;\n        }\n        case 'PX': {\n          if (arguments.length === argc)\n            return BAD_ARGS;\n          optPX = arguments[argc++];\n          /*jshint -W018*/\n          if (!(str2int(optPX) > 0))\n            return BAD_INT;\n          break;\n        }\n      }\n    }\n\n    if (optNX) {\n      if (this.EXISTS(key)) return null;\n    }\n\n    if (optXX) {\n      if (!this.EXISTS(key)) return null;\n    }\n\n    this.setKey(key, new STRING(buf));\n\n    if (optEX) {\n      this.EXPIRE(key, optEX);\n    }\n\n    if (optPX) {\n      this.PEXPIRE(key, optPX);\n    }\n\n    return OK;\n  }\n\n, sIncrBy: function (parse, key, incr) {\n    var K = this.getKey(STRING, key, true);\n    if (K instanceof ERROR) return K;\n\n    incr = parse(incr);\n    if (incr instanceof ERROR) return incr;\n    var value = parse(K.value.toString() || \"0\");\n    if (value instanceof ERROR) return value;\n\n    value = (value + incr).toString();\n    var buf = new Buffer(Buffer.byteLength(value));\n      buf.write(value);\n\n    K.value = value;\n    this.upsetKey(key, K);\n    return value;\n  }\n\n, sFit: function (key, length) {\n    var K = this.getKey(STRING, key, true);\n    if (K instanceof ERROR) return ERROR;\n\n    if (K.value.length < length) {\n      var buf = new Buffer(length);\n        buf.fill(0);\n\n      K.value.copy(buf);\n      K.value = buf;\n    }\n\n    return K;\n  }\n\n, SETBIT: function (key, offset, state) {\n    /*jshint -W018*/\n    offset = str2int(offset);\n    if (!(offset >  - 1)) return BAD_BIT1;\n    state = str2int(state);\n    if (!(state === 0 || state === 1)) return BAD_BIT2;\n\n    var x = Math.floor(offset / 8);\n    var K = this.sFit(key, x + 1);\n    if (K instanceof ERROR) return K;\n\n    var mask = 1 << (7 - (offset % 8));\n    var current = K.value[x];\n    var old = current & mask ? 1 : 0;\n\n    if (state && !old)\n      K.value[x] = current | mask;\n    else if (!state && old)\n      K.value[x] = current & ~mask;\n\n    this.upsetKey(key, K);\n    return old;\n  }\n\n, SETRANGE: function (key, offset, value) {\n    /*jshint -W018*/\n    offset = str2int(offset);\n    if (!(offset >  - 1)) return BAD_BIT1;\n\n    var K = this.sFit(key, offset + Buffer.byteLength(value));\n    K.value.write(value, offset);\n\n    this.upsetKey(key, K);\n    return this.STRLEN(key);\n  }\n\n\n  // String getters.\n\n, GET: function (key) {\n    var K = this.getKey(STRING, key);\n    if (K instanceof ERROR) return K;\n    return K ? K.value.toString() : null;\n  }\n\n, STRLEN: function (key) {\n    var K = this.getKey(STRING, key);\n    if (K instanceof ERROR) return ERROR;\n    return K ? K.value.length : 0;\n  }\n\n, GETBIT: function (key, offset) {\n    /*jshint -W018*/\n    var K = this.getKey(STRING, key);\n    if (K instanceof ERROR) return ERROR;\n\n    offset = str2int(offset);\n    if (!(offset >  - 1)) return BAD_BIT1;\n    var x = Math.floor(offset / 8);\n    if (!K || K.length < x + 1) return 0;\n\n    var mask = 1 << (7 - (offset % 8));\n    return (K.value[x]& mask)? 1 : 0;\n  }\n\n, GETRANGE: function (key, start, stop) {\n    var K = this.getKey(STRING, key);\n    if (K instanceof ERROR) return ERROR;\n    if (!K) return \"\";\n\n    var out = slice(K.value, start, stop);\n    if (out instanceof ERROR) return out;\n    return out.toString();\n  }\n\n, BITCOUNT: function () {\n    var key = arguments[0];\n    var start = arguments[1] || 0;\n    var stop = arguments[2] || -1;\n\n    if (!key) return BAD_ARGS;\n\n    var K = this.GETRANGE(key, start.toString(), stop.toString());\n    if (K instanceof ERROR) return ERROR;\n    if (!K) return 0;\n\n    var bitCount = 0;\n    var buff = new Buffer(K);\n    for (var i = 0; i < buff.length; i++) {\n      bitCount += populationCount(buff[i].toString());\n    }\n\n    return bitCount;\n  }\n\n\n  // String ops.\n\n, APPEND: function (key, value) {\n    var strlen = this.STRLEN(key);\n    if (strlen instanceof ERROR) return strlen;\n    return this.SETRANGE(key, strlen.toString(), value);\n  }\n\n, DECR: function (key) {\n    return this.DECRBY(key, \"1\");\n  }\n\n, DECRBY: function (key, decr) {\n    var value = str2int(decr);\n    if (value instanceof ERROR) return value;\n    return this.INCRBY(key, ( - value).toString());\n  }\n\n, GETSET: function (key, value) {\n    var old = this.GET(key);\n    if (old instanceof ERROR) return old;\n    this.SET(key, value);\n    return old;\n  }\n\n, INCR: function (key) {\n    return this.INCRBY(key, \"1\");\n  }\n\n, INCRBY: function (key, incr) {\n    return this.sIncrBy(str2int, key, incr);\n  }\n\n, INCRBYFLOAT: function (key, incr) {\n    return this.sIncrBy(str2float, key, incr);\n  }\n\n, MGET: function () {\n    var out = [], i, n = arguments.length;\n    if (!n) return BAD_ARGS;\n\n    for (i = 0; i < n; i++) {\n      var value = this.GET(arguments[i]);\n      out[i] = value instanceof ERROR ? null : value;\n    }\n\n    return out;\n  }\n\n, MSET: function () {\n    var key, value, i, n = arguments.length;\n    if (!n || n % 2) return BAD_ARGS;\n\n    for (i = 0; i < n; i += 2) {\n      key = arguments[i];\n      value = arguments[i + 1];\n      this.SET(key, value);\n    }\n\n    return OK;\n  }\n\n, MSETNX: function () {\n    var i, n = arguments.length;\n    for (i = 0; i < n; i += 2)\n      if (this.EXISTS(arguments[i])) return 0;\n\n    this.MSET.apply(this, arguments);\n    return 1;\n  }\n\n, PSETEX: function (key, timediff, value) {\n    /*jshint -W018*/\n    if (!(str2int(timediff) > 0))\n      return BAD_SETEX;\n\n    this.SET(key, value);\n    this.PEXPIRE(key, timediff);\n    return OK;\n  }\n\n, SETEX: function (key, timediff, value) {\n    /*jshint -W018*/\n    if (!(str2int(timediff) > 0))\n      return BAD_SETEX;\n\n    this.SET(key, value);\n    this.EXPIRE(key, timediff);\n    return OK;\n  }\n\n, SETNX: function (key, value) {\n    if (this.EXISTS(key)) return 0;\n    this.SET(key, value);\n    return 1;\n  }\n\n\n  // Lists, non-blocking.\n\n, lStore: function (key, values) {\n    // Only used in SORT.\n\n    if (values.length)\n      return this.setKey(key, new LIST(values));\n    else\n      return this.setKey(key, null);\n  }\n\n, LINDEX: function (key, index) {\n    var K = this.getKey(LIST, key);\n    if (K instanceof ERROR) return K;\n\n    index = str2int(index);\n    if (index instanceof ERROR)\n      return index;\n\n    return (K && K.value[index < 0 ? K.value.length + index : index]) || null;\n  }\n\n, upsetList: function (key, K) {\n    if (K.value.length) this.upsetKey(key, K);\n    else this.setKey(key, null);\n  }\n\n, LINSERT: function (key, relpos, pivot, value) {\n    var K = this.getKey(LIST, key), x;\n    if (K instanceof ERROR) return K;\n\n    relpos = relpos.toUpperCase();\n    if (relpos !== 'BEFORE' && relpos !== 'AFTER') return BAD_SYNTAX;\n    if (!K) return 0;\n    if ((x = K.value.indexOf(pivot)) < 0) return 0;\n\n    K.value.splice(relpos === 'AFTER'? x + 1 : x, 0, value);\n    this.upsetList(key, K);\n    return 1;\n  }\n\n, LLEN: function (key) {\n    var K = this.getKey(LIST, key);\n    if (K instanceof ERROR) return K;\n\n    return (K && K.value && K.value.length) || 0;\n  }\n\n, lPopMany: function (left, keys) {\n    var K = [], value, i, n = keys.length;\n    if (!n) return BAD_ARGS;\n    for (i = 0; i < n; i++) {\n      K[i] = this.getKey(LIST, keys[i]);\n      if (K[i]instanceof ERROR) return K[i];\n    }\n    for (i = 0; i < n; i++)\n      if (K[i] && K[i].value && K[i].value.length) {\n        value = left ? K[i].value.shift() : K[i].value.pop();\n        this.upsetList(keys[i], K[i]);\n        return [keys[i], value];\n      }\n\n    return null;\n  }\n\n, lPop: function (left, key) {\n    var out = this.lPopMany(left, [key]);\n    return out && out.length ? out[1] : out;\n  }\n\n, LPOP: function (key) {\n    return this.lPop(true, key);\n  }\n\n, RPOP: function (key) {\n    return this.lPop(false, key);\n  }\n\n, lPush: function (left, make, args) {\n    var i, n = args.length, key = args[0];\n    var K = this.getKey(LIST, key, make);\n    if (K instanceof ERROR) return K;\n    if (n < 2) return BAD_ARGS;\n    if (!K) return 0;\n\n    if (left) for (i = 1; i < n; i++)\n      K.value.unshift(args[i]);\n    else\n      K.value.push.apply(K.value, args.slice(1));\n\n    this.upsetList(key, K);\n    return K.value.length;\n  }\n\n, LPUSH: function () {\n    return this.lPush(true, true, arr(arguments));\n  }\n\n, LPUSHX: function () {\n    return this.lPush(true, false, arr(arguments));\n  }\n\n, RPUSH: function () {\n    return this.lPush(false, true, arr(arguments));\n  }\n\n, RPUSHX: function () {\n    return this.lPush(false, false, arr(arguments));\n  }\n\n, RPOPLPUSH: function (source, destination) {\n    var dest = this.getKey(LIST, destination);\n    if (dest && dest instanceof ERROR) return dest;\n    var value = this.RPOP(source);\n    if (value === null || value instanceof ERROR) return value;\n\n    var len = this.LPUSH(destination, value);\n    if (!len || len instanceof ERROR) throw new Error(\"WOOT! LPUSH failed in RPOPLPUSH.\");\n\n    return value;\n  }\n\n, LRANGE: function (key, start, stop) {\n    var K = this.getKey(LIST, key);\n    if (K instanceof ERROR) return K;\n    if (!K) return [];\n\n    return slice(K.value, start, stop);\n  }\n\n, LREM: function (key, count, value) {\n    var K = this.getKey(LIST, key);\n    if (K instanceof ERROR) return K;\n    count = str2int(count);\n    if (count instanceof ERROR) return count;\n    if (!K) return 0;\n\n    var i, n = K.value.length, x = 0;\n    if (count < 0) {\n      count *=  - 1;\n      for (i = n - 1; i >= 0; i--)\n        if (K.value[i] === value && (!count || x < count)) {\n          K.value.splice(i, 1);\n          x++;\n        }\n    }\n    else for (i = 0; i < n; i++)\n      if (K.value[i] === value && (!count || x < count)) {\n        K.value.splice(i, 1);\n        i--; n--; x++;\n      }\n\n    if (x > 0) this.upsetList(key, K);\n    return x;\n  }\n\n, LSET: function (key, index, value) {\n    var K = this.getKey(LIST, key);\n    if (!K) return BAD_KEY;\n    if (K instanceof ERROR) return K;\n    index = str2int(index);\n    if (index instanceof ERROR) return index;\n    if (index < 0 || index > K.value.length) return BAD_INDEX;\n\n    K.value[index] = value;\n    this.upsetList(key, K);\n    return OK;\n  }\n\n, LTRIM: function (key, start, stop) {\n    var range = this.LRANGE(key, start, stop);\n    if (!range.join)\n      return range;\n\n    var K = this.getKey(LIST, key);\n    if (K) {\n      K.value = range;\n      this.upsetList(key, K);\n    }\n\n    return OK;\n  }\n\n\n  // Blocking list commands.\n  // The blocking part happens at the connection level,\n  // where in case the response is null the connection subscribes to the keyspace change event for the key and waits to retry.\n\n  // So this only validates the parameter.\n\n, bArgs: function (args) {\n    args = arr(args);\n    var timeout = str2int(args.pop() || \"FAIL\");\n    if (timeout instanceof ERROR) return timeout;\n    if (timeout < 0) return BAD_INT;\n    return args;\n  }\n\n, BLPOP: function () {\n    var a = this.bArgs(arguments);\n    if (a instanceof ERROR) return a;\n    return this.lPopMany(true, a);\n  }\n\n, BRPOP: function () {\n    var a = this.bArgs(arguments);\n    if (a instanceof ERROR) return a;\n    return this.lPopMany(false, a);\n  }\n\n, BRPOPLPUSH: function () {\n    var a = this.bArgs(arguments);\n    if (a instanceof ERROR) return a;\n    return this.RPOPLPUSH.apply(this, a);\n  }\n\n\n  // Hashes.\n\n, structPut: function (type, validate, revArgs, args) {\n    var key = args[0], i, n = args.length, x = 0;\n\n    if (n < 3 || ((n - 1) % 2)) return BAD_ARGS;\n    var K = this.getKey(type, key, true);\n    if (K instanceof ERROR) return K;\n\n    for (i = 1; i < n; i += 2) {\n      var member = args[revArgs ? i + 1 : i]\n        , value = validate(args[revArgs ? i : i + 1]);\n      if (value instanceof ERROR) return value;\n      if (!(member in K.value)) x++;\n      K.value[member] = value;\n    }\n\n    if (x) this.upsetKey(key, K);\n    return x;\n  }\n\n, structDel: function (type, args) {\n    var key = args[0]\n      , i, n = args.length\n      , x;\n\n    if (n < 2) return BAD_ARGS;\n    var K = this.getKey(type, key);\n    if (K instanceof ERROR) return K;\n    if (!K) return 0;\n\n    x = 0;\n    for (i = 1; i < n; i++) {\n      if (args[i]in K.value) x++;\n      delete K.value[args[i]];\n    }\n\n    // Remove the set if empty, upset otherwise.\n\n    var member;\n    for (member in K.value) {\n      if (x) this.upsetKey(key, K);\n      return x;\n    }\n\n    this.setKey(key, null);\n    return x;\n  }\n\n, structGet: function (type, key, member) {\n    var K = this.getKey(type, key);\n    if (K instanceof ERROR) return K;\n    if (!K || !(member in K.value)) return null;\n    return K.value[member];\n  }\n\n, HDEL: function () {\n    return this.structDel(HASH, arguments);\n  }\n\n, HEXISTS: function (key, field) {\n    var fields = this.HKEYS(key);\n    if (fields.indexOf) return fields.indexOf(field) >= 0 ? 1 : 0;\n    return fields;\n  }\n\n, HGET: function (key, field) {\n    return this.structGet(HASH, key, field);\n  }\n\n, HGETALL: function (key) {\n    var fields = this.HKEYS(key);\n    var i, n = fields.length, out = [];\n    for (i = 0; i < n; i++)\n      out.push(fields[i], this.HGET(key, fields[i]));\n\n    return out;\n  }\n\n, hIncrBy: function (parse, key, field, incr) {\n    var K = this.getKey(HASH, key, true);\n    if (K instanceof ERROR) return K;\n\n    incr = parse(incr);\n    if (incr instanceof ERROR) return incr;\n    var value = parse(K.value[field] || \"0\");\n    if (value instanceof ERROR) return value;\n\n    K.value[field] = (value + incr).toString();\n    this.upsetKey(key, K);\n    return K.value[field];\n  }\n\n, HINCRBY: function (key, field, incr) {\n    return this.hIncrBy(str2int, key, field, incr);\n  }\n\n, HINCRBYFLOAT: function (key, field, incr) {\n    return this.hIncrBy(str2float, key, field, incr);\n  }\n\n, HKEYS: function (key) {\n    var K = this.getKey(HASH, key);\n    if (K instanceof ERROR) return K;\n\n    var fields = [], field;\n    if (K) for (field in K.value)\n      fields.push(field);\n\n    fields.sort();\n    return fields;\n  }\n\n, HLEN: function (key) {\n    var fields = this.HKEYS(key);\n    if (fields.indexOf) return fields.length;\n    return fields;\n  }\n\n, HMGET: function () {\n    var K = this.getKey(HASH, arguments[0]);\n    if (K instanceof ERROR) return K;\n\n    var i, n = arguments.length, values = [];\n    if (n < 2) return BAD_ARGS;\n    for (i = 1; i < n; i++)\n      values.push(K && arguments[i]in K.value ? K.value[arguments[i]] : null);\n\n    return values;\n  }\n\n, HMSET: function () {\n    var x = this.structPut(HASH, String, false, arguments);\n    return x instanceof ERROR ? x : OK;\n  }\n\n, HSET: function () {\n    return this.structPut(HASH, String, false, arguments);\n  }\n\n, HSETNX: function (key, field, value) {\n    var exists = this.HEXISTS(key, field);\n    if (exists instanceof ERROR) return exists;\n    if (exists) return 0;\n    return this.HSET(key, field, value);\n  }\n\n, HVALS: function (key) {\n    var out = this.HKEYS(key), self = this;\n    if (out instanceof ERROR) return out;\n\n    if (out.map)\n      out = out.map(function (field) {\n        return self.HGET(key, field);\n      });\n\n    out.sort();\n    return out;\n  }\n\n\n  // Sets.\n\n, SADD: function () {\n    var key = arguments[0]\n      , i, n = arguments.length\n      , x = 0;\n\n    if (n < 2) return BAD_ARGS;\n    var K = this.getKey(SET, key, true);\n    if (K instanceof ERROR) return K;\n\n    for (i = 1; i < n; i++)\n      if (!K.value[arguments[i]]) {\n        K.value[arguments[i]] = true;\n        x++;\n      }\n\n    if (x) this.upsetKey(key, K);\n    return x;\n  }\n\n, SCARD: function (key) {\n    var members = this.SMEMBERS(key);\n    return members.join ? members.length : members;\n  }\n\n, SISMEMBER: function (key, member) {\n    var members = this.SMEMBERS(key);\n    return members.indexOf ? members.indexOf(member) >= 0 ? 1 : 0: members;\n  }\n\n, SMEMBERS: function (key) {\n    return this.SUNION(key);\n  }\n\n, SPOP: function (key) {\n    var member = this.SRANDMEMBER(key);\n    if (typeof member === 'string')\n      this.SREM(key, member);\n\n    return member;\n  }\n\n, SRANDMEMBER: function (key) {\n    var members = this.SMEMBERS(key)\n      , n = members.length, member;\n    if (!n)\n      return n === 0 ? null : members;\n\n    member = members[Math.floor(Math.random()* n)];\n    return member;\n  }\n\n, SREM: function () {\n    return this.structDel(SET, arguments);\n  }\n\n\n  // Set multikey ops.\n  // Set members come out sorted lexicographically to facilitate testing.\n\n, SMOVE: function (source, destination, member) {\n    var removed = this.SREM(source, member);\n    if (removed === 1)\n      return this.SADD(destination, member);\n    else\n      return removed;\n  }\n\n, SUNION: function () {\n    var i, n = arguments.length, out = [];\n    if (!n) return BAD_ARGS;\n\n    for (i = 0; i < n; i++) {\n      var K = this.getKey(SET, arguments[i]);\n      if (K instanceof ERROR) return K;\n\n      var member;\n      if (K) for (member in K.value)\n        if (out.indexOf(member) < 0)\n          out.push(member);\n    }\n\n    out.sort();\n    return out;\n  }\n\n, sCombine: function (diff, args) {\n    var i, n = args.length;\n    if (!n)\n      return BAD_ARGS;\n\n    var out = this.SUNION(args[0]);\n    if (out instanceof ERROR) return out;\n    for (i = 1; i < n; i++) {\n      var K = this.getKey(SET, args[i]);\n      if (K instanceof ERROR) return K;\n\n      var j, m = out.length;\n      for (j = 0; j < m; j++)\n        if ((diff && (K && K.value[out[j]])) || (!diff && !(K && K.value[out[j]]))) {\n          out.splice(j, 1);\n          j--;\n          m--;\n        }\n    }\n\n    out.sort();\n    return out;\n  }\n\n, SDIFF: function () {\n    return this.sCombine(true, arr(arguments));\n  }\n\n, SINTER: function () {\n    return this.sCombine(false, arr(arguments));\n  }\n\n, sStore: function (key, members) {\n    var K, i, n = members.length;\n    if (n) K = new SET({});\n    for (i = 0; i < n; i++)\n      K.value[members[i]] = true;\n\n    return this.setKey(key, K || null);\n  }\n\n, sStoreOp: function (op, args) {\n    if (!args.length)\n      return BAD_ARGS;\n\n    var key = args.shift()\n      , members = op.apply(this, args);\n\n    if (members.join) {\n      this.sStore(key, members);\n      return members.length;\n    }\n\n    return members;\n  }\n\n, SDIFFSTORE: function () {\n    return this.sStoreOp(this.SDIFF, arr(arguments));\n  }\n\n, SINTERSTORE: function () {\n    return this.sStoreOp(this.SINTER, arr(arguments));\n  }\n\n, SUNIONSTORE: function () {\n    return this.sStoreOp(this.SUNION, arr(arguments));\n  }\n\n\n  // Sorted sets.\n\n, ZADD: function () {\n    return this.structPut(ZSET, str2float, true, arguments);\n  }\n\n, ZCARD: function (key) {\n    return this.ZCOUNT(key, '-inf', '+inf');\n  }\n\n, ZCOUNT: function (key, min, max) {\n    var members = this.ZRANGEBYSCORE(key, min, max);\n    return members.join ? members.length : members;\n  }\n\n, ZINCRBY: function (key, incr, member) {\n    var K = this.getKey(ZSET, key, true);\n    if (K instanceof ERROR) return K;\n\n    var value = str2float(incr);\n    if (value instanceof ERROR) return value;\n    value += Number(K.value[member] || 0);\n\n    K.value[member] = value;\n    this.upsetKey(key, K);\n    return value;\n  }\n\n\n  // Sort set queries.\n\n, zSort: function (rev, key, min, max) {\n    var K = this.getKey(ZSET, key);\n    if (K instanceof ERROR) return K;\n    if (!K) return [];\n\n    var rng = range(min, max), member, out = [];\n    if (rng instanceof ERROR) return rng;\n\n    for (member in K.value)\n      if (rng(K.value[member]))\n        out.push({ member: member, score: K.value[member] });\n\n    // First by score,\n    // then in lexicographic order.\n\n    if (rev)\n      out.sort(function (b, a) {\n        return (a.score - b.score) || (a.member < b.member ? - 1 : 1);\n      });\n\n    else\n      out.sort(function (a, b) {\n        return (a.score - b.score) || (a.member < b.member ? - 1 : 1);\n      });\n\n    return out;\n  }\n\n, zUnwrap: function (range, scores) {\n    var i, n = range.length, out = n ?[] : range;\n    if (n)\n      for (i = 0; i < n; i++) {\n        out.push(range[i].member);\n        if (scores)\n          out.push(range[i].score);\n      }\n\n    return out;\n  }\n\n, zGetRange: function (rev, args) {\n    var key = args[0], start = args[1], stop = args[2], scores = args[3];\n\n    if (args.length < 3 || args.length > 4)\n      return BAD_ARGS;\n    if (scores && scores.toUpperCase() !== 'WITHSCORES')\n      return BAD_SYNTAX;\n\n    var range = this.zSort(rev, key, '-inf', '+inf');\n\n    return this.zUnwrap(slice(range, start, stop), scores);\n  }\n\n, zGetRangeByScore: function (rev, args) {\n    var key = args[0], min = args[rev ? 2 : 1], max = args[rev ? 1 : 2]\n      , scores, limit, offset, count;\n\n    if (args.length < 3)\n      return BAD_ARGS;\n\n    else if (args.length === 4)\n      scores = args[3];\n\n    else if (args.length === 6) {\n      limit = args[3];\n      offset = args[4];\n      count = args[5];\n    }\n\n    else if (args.length === 7) {\n      scores = args[3];\n      limit = args[4];\n      offset = args[5];\n      count = args[6];\n    }\n\n    if (scores && scores.toUpperCase() !== 'WITHSCORES')\n      return BAD_SYNTAX;\n    if (limit && limit.toUpperCase() !== 'LIMIT')\n      return BAD_SYNTAX;\n\n    var range = this.zSort(rev, key, min, max);\n    if (limit)\n      range = slice(range, offset, count, true);\n\n    return this.zUnwrap(range, scores);\n  }\n\n, ZRANGE: function () {\n    return this.zGetRange(false, arr(arguments));\n  }\n\n, ZREVRANGE: function () {\n    return this.zGetRange(true, arr(arguments));\n  }\n\n, ZRANGEBYSCORE: function () {\n    return this.zGetRangeByScore(false, arr(arguments));\n  }\n\n, ZREVRANGEBYSCORE: function () {\n    return this.zGetRangeByScore(true, arr(arguments));\n  }\n\n, ZRANK: function (key, member) {\n    var out = this.zSort(false, key, '-inf', '+inf')\n      , i, n = out.length;\n\n    for (i = 0; i < n; i++)\n      if (out[i].member === member)\n        return i;\n\n    return n || n === 0 ? null : out;\n  }\n\n, ZREVRANK: function (key, member) {\n    var out = this.zSort(false, key, '-inf', '+inf')\n      , i, n = out.length;\n\n    for (i = n - 1; i >= 0; i--)\n      if (out[i].member === member)\n        return n - i - 1;\n\n    return n || n === 0 ? null : out;\n  }\n\n, ZSCORE: function (key, member) {\n    return this.structGet(ZSET, key, member);\n  }\n\n, ZREM: function () {\n    return this.structDel(ZSET, arguments);\n  }\n\n, ZREMRANGEBYRANK: function (key, start, stop) {\n    var members = this.ZRANGE(key, start, stop), n = members.length;\n    if (n)\n      n = this.ZREM.apply(this, [key].concat(members));\n\n    return n || n === 0 ? n : members;\n  }\n\n, ZREMRANGEBYSCORE: function (key, min, max) {\n    var members = this.ZRANGEBYSCORE(key, min, max), n = members.length;\n    if (n)\n      n = this.ZREM.apply(this, [key].concat(members));\n\n    return n || n === 0 ? n : members;\n  }\n\n\n  // Sorted set multikey ops.\n\n, getSetOrZsetKey: function (key) {\n    var K;\n    var type = this.TYPE(key);\n    if (type === ZSET || type === SET) {\n      K = this.getKey(type, key);\n    }\n\n    return K;\n}\n\n\n, zOpStore: function (union, key, keys, weights, aggregate) {\n    var K = this.getSetOrZsetKey(keys[0]);\n    if (K instanceof ERROR) return K;\n\n    var out = {}, member, x = 0, weight = (weights === null ? 1 : weights[0]);\n    if (K) for (member in K.value) {\n      out[member] = K.value[member]* weight;\n      x++;\n    }\n\n    var i, n = keys.length;\n    for (i = 1; i < n; i++) {\n      K = this.getSetOrZsetKey(keys[i]);\n      if (K instanceof ERROR) return K;\n\n      weight = (weights !== null ? weights[i] : 1);\n      if (!union) {\n        if (!K) {\n          out = {};\n          x = 0;\n        }\n\n        else for (member in out) if (!(member in K.value)) {\n          delete out[member];\n          x--;\n        }\n      }\n\n      if (K) for (member in K.value)\n        if (union || member in out) {\n          if (!(member in out)) {\n            x++;\n            out[member] = K.value[member]* weight;\n          }\n\n          else\n            out[member] = aggregate(K.value[member]* weight, out[member]);\n        }\n    }\n\n    if (x) this.setKey(key, new ZSET(out));\n    return x;\n  }\n\n, zsum: function (a, b) { return a + b; }\n, zmin: function (a, b) { return a < b ? a : b; }\n, zmax: function (a, b) { return a > b ? a : b; }\n\n, zParseOpStore: function (union, args) {\n    var key = args[0], N = str2int(args[1]);\n    if (N instanceof ERROR) return N;\n    if (N < 1) return BAD_ZUIS;\n    if (args.length < N + 2) return BAD_ARGS;\n\n    var keys = args.splice(2, N), weigh = (args[2] || '').toUpperCase() === 'WEIGHTS', weights;\n    if (weigh) {\n      if (args.length < N + 3) return BAD_ARGS;\n      weights = args.splice(3, N);\n      if (weights.map(str2float).some(function (w) { return w instanceof ERROR; })) return BAD_FLOAT;\n      args.splice(2, 1);\n    }\n\n    var aggregate = (args[2] || '').toUpperCase() === 'AGGREGATE' ? (args[3] || '').toLowerCase() : null;\n    if (aggregate) {\n      if (aggregate !== 'sum' && aggregate !== 'min' && aggregate !== 'max') return BAD_SYNTAX;\n      aggregate = this['z' + aggregate];\n      if (typeof aggregate !== 'function')\n        throw new Error(\"WOOT! Can't find the aggregate function for \" + args[3]);\n      args.splice(2, 2);\n    }\n\n    if (args.length !== 2)\n      return BAD_ARGS;\n\n    return this.zOpStore(union, key, keys, weights || null, aggregate || this.zsum);\n  }\n\n, ZINTERSTORE: function () {\n    return this.zParseOpStore(false, arr(arguments));\n  }\n\n, ZUNIONSTORE: function () {\n    return this.zParseOpStore(true, arr(arguments));\n  }\n\n\n  // Sort.\n\n, sortSelect: function (pat, kkey) {\n    var select = /^((?:.)*?)(?:->(.*))?$/.exec(pat)\n      , key = select[1].replace(/\\*/, kkey),  // no g flag, so only first occurence is replaced\n      field = select[2];\n\n    if (typeof field === 'string')\n      return this.HGET(key, field);\n    else\n      return this.GET(key);\n  }\n\n, SORT: function () {\n    var self = this, args = arr(arguments), n = args.length;\n    if (!n) return new BAD_ARGS;\n\n    // Parse.\n    // SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]\n\n    var key = args.shift()\n      , by, limit, offset, count, get, pat, desc, alpha, store\n      , seenAscDesc = false;\n\n    if (/^by$/i.test(args[0])) {\n      by = args[1];\n      if (typeof by !== 'string') return BAD_SYNTAX;\n      args.splice(0, 2);\n    }\n\n    if (/^limit$/i.test(args[0])) {\n      limit = true;\n      if (args.length < 3) return BAD_ARGS;\n      offset = args[1]; // integer validation happens in slice()\n      count = args[2];\n      args.splice(0, 3);\n    }\n\n    if (/^asc|desc$/i.test(args[0])) {\n      desc = /^desc$/i.test(args[0]);\n      args.splice(0, 1);\n      seenAscDesc = true;\n    }\n\n    while (/^get$/i.test(args[0])) {\n      pat = args[1];\n      if (typeof pat !== 'string') return BAD_SYNTAX;\n      if (!get) get = [];\n      get.push(pat);\n      args.splice(0, 2);\n    }\n\n    if (!seenAscDesc)\n      if (/^asc|desc$/i.test(args[0])) {\n        desc = /^desc$/i.test(args[0]);\n        args.splice(0, 1);\n        seenAscDesc = true;\n      }\n\n    if (/^alpha$/i.test(args[0])) {\n      alpha = true;\n      args.splice(0, 1);\n    }\n\n    if (/^store$/i.test(args[0])) {\n      store = args[1];\n      if (typeof store !== 'string') return BAD_SYNTAX;\n      args.splice(0, 2);\n    }\n\n    // Redis appears to accept params in any order,\n    // needs some tests before allowing this here.\n\n    if (args.length) return BAD_SYNTAX;\n\n    // Collect data.\n\n    var type = this.TYPE(key), data, scoreFail = false;\n\n    if (type === NONE)\n      data = [];\n    else if (type === LIST)\n      data = this.LRANGE(key, '0', '-1');\n    else if (type === SET)\n      data = this.SMEMBERS(key);\n    else if (type === ZSET)\n      data = this.ZRANGE(key, '0', '-1');\n    else\n      return BAD_TYPE;\n\n    data = data.map(function (id) {\n      var entry = { id: id };\n      if (by) {\n        entry.by = self.sortSelect(by, id);\n        if (!alpha)\n          entry.num = str2float(entry.by || '0');\n      }\n      else if (!alpha)\n        entry.num = str2float(id);\n      else\n        entry.num = 0;\n\n      if (entry.num instanceof ERROR)\n        scoreFail = true;\n\n      if (get)\n        entry.get = get.map(function (get) {\n          if (get === '#') return id;\n          return self.sortSelect(get, id);\n        });\n\n      return entry;\n    });\n\n    if (scoreFail) return BAD_SORT;\n\n    // Sort.\n\n    data.sort(function (a, b) {\n      var d = a.num - b.num;\n      if (!d && by) d = a.by < b.by ? - 1 : a.by > b.by ? 1 : 0;\n      if (!d) d = a.id < b.id ? - 1 : a.id > b.id ? 1 : 0;\n      return desc ? - d : d;\n    });\n\n    // Limit.\n\n    if (parseInt(offset, 10) < 0)\n      offset = '0'; // SORT treats negative offset limit differently from other redis commands.\n\n    if (limit) data = slice(data, offset, count, true);\n\n    // Format.\n\n    var out = [], i;\n    n = data.length;\n    for (i = 0; i < n; i++) {\n      if (get) out.push.apply(out, data[i].get);\n      else out[i] = data[i].id;\n    }\n\n    // Store or return.\n\n    if (store) {\n      this.lStore(store, out);\n      return this.LLEN(store);\n    }\n    else\n      return out;\n  }\n\n\n  // Pubsub.\n\n, PUBLISH: function (channel, message) {\n    return this.pub(channel, message);\n  }\n\n\n  // Connection.\n  // Quit and select could be implemented on the connection object.\n\n, PING: function () {\n    if (arguments.length)\n      return BAD_ARGS;\n\n    return PONG;\n  }\n\n, ECHO: function (message) {\n    return message;\n  }\n\n\n  // Server.\n  // FLUSHALL can be implemented on the connection object.\n\n, DBSIZE: function () {\n    return this.getKeys().length;\n  }\n\n, FLUSHDB: function () {\n    var keys = this.getKeys(), i, n = keys.length;\n    for (i = 0; i < n; i++)\n      this.setKey(keys[i], null);\n\n    return OK;\n  }\n\n, TIME: function () {\n    var time = Date.now()\n      , sec = Math.round(time / 1000)\n      , msec = (time % 1000)* 1000 + Math.floor(Math.random()* 1000);\n\n    return [sec, msec];\n  }\n\n\n  // Helper commands.\n\n, FAKE_DUMP: function (pattern) {\n    var keys = this.KEYS(pattern), i, n = keys.length, out = [], key, type;\n\n    for (i = 0; i < n; i++) {\n      key = keys[i];\n      type = this.TYPE(key);\n      out.push(key, this.TTL(key), type.getStatus());\n\n      if (type === STRING)\n        out.push(this.GET(key));\n      else if (type === LIST)\n        out.push(this.LRANGE(key, '0', '-1'));\n      else if (type === HASH)\n        out.push(this.HGETALL(key));\n      else if (type === SET)\n        out.push(this.SMEMBERS(key));\n      else if (type === ZSET)\n        out.push(this.ZRANGE(key, '0', '-1', 'withscores'));\n      else\n        throw new Error(\"WOOT! Key type is \" + type);\n    }\n\n    return out;\n  }\n};\n\n\n// These don't have an effect on the dataset, so dummies are safe for tests.\n\nexports.Backend.prototype.AUTH =\nexports.Backend.prototype.BGREWRITEAOF =\nexports.Backend.prototype.SAVE =\nexports.Backend.prototype.BGSAVE = function () { return OK; };\n\n\n// All of these are implemented at the connection level.\n\nexports.Backend.prototype.QUIT =\n\nexports.Backend.prototype.SUBSCRIBE =\nexports.Backend.prototype.PSUBSCRIBE =\nexports.Backend.prototype.UNSUBSCRIBE =\nexports.Backend.prototype.PUNSUBSCRIBE =\n\nexports.Backend.prototype.MULTI =\nexports.Backend.prototype.EXEC =\nexports.Backend.prototype.WATCH =\nexports.Backend.prototype.UNWATCH =\nexports.Backend.prototype.SELECT =\nexports.Backend.prototype.DISCARD = function () { throw new Error(\"WOOT! This command shouldn't have reached the backend.\"); };\n","/home/travis/build/npmtest/node-npmtest-fakeredis/node_modules/fakeredis/lib/connection.js":"\"use strict\";\n\n\nexports.Connection = function(backend, minLatency, maxLatency) {\n  var connection = this\n    , db = 0\n\n    , queue, watch, block\n\n    , timeout = 0\n    , state = NORMAL\n    , subs = 0;\n\n\n  this.push = function(client, command, args, callback) {\n    state(client, prep(command, args, callback));\n  };\n\n\n  // Push a command to a normal connection.\n\n  function NORMAL(client, entry) {\n    var i, n, matches;\n\n\n    // Transactions.\n\n    if (entry.command === \"WATCH\") {\n      entry.override = function() {\n        var i, n = entry.args.length;\n        if (!watch)\n          watch = {};\n        for (i = 0; i < n; i++)\n          if (!(entry.args[i]in watch))\n            watch[entry.args[i]] = backend.getRevision(entry.args[i]);\n\n        return \"OK\";\n      };\n    }\n\n    else if (entry.command === \"UNWATCH\") {\n      entry.override = function() {\n        watch = null;\n        return \"OK\";\n      };\n    }\n\n    else if (entry.command === \"DISCARD\") {\n      if (queue) {\n        if (!timeout)\n          timeout = setTimeout(exec, randLat());\n\n        for (i = 0; i < queue.length; i++)\n          if (queue[i].command === \"MULTI\") {\n            queue.splice(i, queue.length);\n\n            // This will substitute the DISCARD command with an UNWATCH,\n            // hence the recursive call to this.push.\n            return this.push([\"UNWATCH\"], entry.callback);\n          }\n      }\n\n      entry.override = function() { return \"OK\"; };\n    }\n\n    else if (entry.command === \"MULTI\") {\n      /*jshint loopfunc:true*/\n      entry.override = function(queue) {\n        if (!queue) throw new Error('WOOT! no queue.');\n        var w = watch, key, entry;\n        watch = null;\n        if (w) for (key in w)\n          if (backend.getRevision(key) !== w[key]) {\n\n            // Abort because of a change in the watched keyspace.\n            n = 0;\n            while ((entry = queue.shift())) {\n              if (entry.command === \"EXEC\") {\n                entry.override = function() {\n                  var i, out = [];\n                  for (i = 0; i < n; i++)\n                    out[i] = null;\n\n                  return out;\n                };\n\n                queue.unshift(entry);\n                break;\n              }\n\n              n++;\n            }\n\n            return \"OK\";\n          }\n\n        var replies = [];\n        var i, m = queue.length, cb = pushReply.bind(replies);\n        for (i = 0; i < m; i++) {\n          entry = queue[i];\n          if (entry.command !== \"EXEC\") {\n\n            // Collect replies for the EXEC output.\n            entry.callback = cb;\n\n            // Prevent blocking within a transaction.\n            delete entry.block;\n          }\n\n          else {\n\n            // Exec calls back with the entire reply list.\n            entry.override = entry.override.bind(replies);\n            return \"OK\";\n          }\n        }\n\n        throw new Error(\"WOOT! Can't find the EXEC command in the queue.\");\n      };\n\n      // Prevent flushing before the exec.\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = 0;\n      }\n\n      if (queue)\n        queue.push(entry);\n      else\n        queue = [entry];\n\n      return;\n    }\n\n    else if (entry.command === \"EXEC\") {\n      entry.override = function() {\n        return this.join ? this : null;\n      };\n\n      if (queue && !timeout)\n        timeout = setTimeout(exec, randLat());\n    }\n\n\n    // Pubsub.\n\n    if ((matches = /^(P)?(UN)?SUBSCRIBE$/.exec(entry.command))) {\n      if (!client.$PUSHDELAY)\n        client.$PUSHDELAY = new Delay(client, 'pushMessage', minLatency);\n\n      entry.override = function() {\n        var i, n = entry.args.length;\n\n        if (n) for (i = 0; i < n; i++) {\n\n          // Unsubscribe.\n          if (matches[2])\n            subs = backend.unsub(matches[1]? true : false, entry.args[i], client.$PUSHDELAY);\n\n          // Subscribe.\n          else\n            subs = backend.sub(matches[1]? true : false, entry.args[i], client.$PUSHDELAY);\n        }\n\n        else if (matches[2]) {\n\n          // Unsubscribe from all.\n          subs = backend.unsub(matches[1]? true : false, null, client.$PUSHDELAY);\n        }\n\n        else\n          return new Error('Wrong number of arguments for \\'' + matches[0] + '\\' command');\n\n        if (!subs)\n          state = NORMAL;\n\n        return \"OK\";\n      };\n\n      if (!matches[2])\n        state = SUBSCRIBED;\n    }\n\n\n    // Connection.\n\n    if (entry.command === 'QUIT') {\n      entry.override = function() {\n        if (client.$PUSHDELAY) {\n\n          // Unsubscribe.\n          backend.unsub(true, null, client.$PUSHDELAY);\n          backend.unsub(false, null, client.$PUSHDELAY);\n        }\n\n        return \"OK\";\n      };\n\n      state = CLOSED;\n    }\n\n    else if (entry.command === 'SELECT') {\n      entry.override = function() {\n        var n = entry.args.length;\n        if (n !== 1)\n          return new Error(\"Wrong number of arguments for 'SELECT' command.\");\n        var id = Number(entry.args[0]);\n        if ((!id && id !== 0) || id % 1 !== 0 || id < 0)\n          return new Error(\"invalid DB index\");\n\n        db = id;\n        backend.selectDB(db);\n        return \"OK\";\n      };\n    }\n\n    // Regular commands.\n\n    if (queue)\n      queue.push(entry);\n\n    else {\n      queue = [entry];\n      timeout = setTimeout(exec, randLat());\n    }\n  }\n\n\n  // Push a command to a subscribed connection.\n\n  function SUBSCRIBED(client, entry) {\n\n    // Allow commands that modify the subscription set.\n    if (/SUBSCRIBE|^QUIT/.test(entry.command))\n      NORMAL(client, entry);\n    else\n      throw new Error(\"fakeredis: Connection is in pub/sub mode (\" + subs + \" subscriptions).\");\n  }\n\n\n  // Closed connection.\n\n  function CLOSED(client, entry) {\n    throw new Error(\"fakeredis: You've closed this connection with QUIT, cannot \" + entry.command);\n  }\n\n\n  // Blocked connection.\n\n  function BLOCKED(client, entry) {\n    if (!block)\n      block = [client, entry];\n    else\n      block.push(client, entry);\n  }\n\n\n  // Execute everything in the queue sequentially.\n\n  function exec() {\n    timeout = 0;\n    var q = queue, entry, func, out, err, data, resp = [];\n    queue = null;\n\n    if (connection.verbose)\n      console.log('\\n');\n\n    backend.selectDB(db);\n\n    if (q) while ((entry = q.shift())) {\n      if (entry === 'SKIP')\n        continue;\n\n      func = backend[entry.command];\n      out = null;\n\n      if (connection.verbose)\n        console.log(\"fakeredis>\", entry.command, entry.args.join(' '));\n\n      if (entry.override) {\n        out = entry.override(q);\n        err = out instanceof Error ? out : null;\n        data = out instanceof Error ? null : out;\n      }\n\n      else if (!func || typeof func !== 'function')\n        throw new Error('WOOT! Wierd queue entry : ' + JSON.stringify(entry) + ' / ' + JSON.stringify(q));\n\n      else if (func.length && func.length !== entry.args.length) {\n        err = new Error('Wrong number of arguments for \\'' + entry.command.toLowerCase() + '\\' command');\n        data = null;\n      }\n\n      else {\n        out = func.apply(backend, entry.args);\n        err = ((out && out.getError) || null) && new Error(out.getError());\n        data = err ? null : (out && out.getStatus && out.getStatus()) || out;\n\n        // Block if necessary.\n        if (entry.block && err === null && data === null) {\n          if (resp.length)\n            flush(resp);\n\n          q.unshift(entry);\n          queue = q;\n          state = BLOCKED;\n          backend.sub(false, backend.UPDATE, connection);\n\n          if (entry.block && typeof entry.block === 'number')\n            setTimeout(unblock.bind(null, entry), entry.block * 1000);\n\n          return;\n        }\n      }\n\n      if (!err && !data && typeof out === \"undefined\")\n        throw new Error(\"WOOT! Backend returned undefined.\");\n      if (out && out.rev)\n        throw new Error(\"WOOT! Returning the whole keyspace entry.\");\n\n      if (data === true)\n        throw new Error(\"TRUE THAT! \" + JSON.stringify(entry));\n\n      data = fdata(data);\n      if (entry.callback)\n        resp.push(entry.callback.bind(null, err, data));\n    }\n\n    if (connection.verbose)\n      console.log('\\n');\n\n    if (resp.length)\n      flush(resp);\n  }\n\n  function flush(resp) {\n    setTimeout(\n      function() {\n        var i, n;\n\n        n = resp.length;\n        for (i = 0; i < n; i++)\n          resp[i]();\n      },\n      minLatency\n    );\n  }\n\n  function unblock(entry) {\n    if (entry)\n      delete entry.block;\n\n    state = NORMAL;\n    exec();\n\n    if (state === NORMAL) {\n      backend.unsub(false, backend.UPDATE, connection);\n\n      var a = block, i, n = a && a.length;\n      block = null;\n      for (i = 0; i < n; i += 2)\n        NORMAL(a[i], a[i + 1]);\n    }\n  }\n\n  this.pushMessage = function(/* type, channel, message */) {\n\n    // Attempt to unblock on backend keyspace change.\n    unblock();\n  };\n\n\n  // Format data the way it comes out of node_redis.\n\n  function fdata(data) {\n    if (typeof data !== 'object' && typeof data !== 'number' && typeof data !== 'string')\n      throw new Error('WOOT! Data is not an object/string/number : ' + data);\n\n    if (data) {\n      if (typeof data === 'string' && !isNaN(data))\n        data = Number(data);\n\n      else if (data.length && data.map)\n        data = data.map(finnerdata);\n\n      else if (typeof data === 'object' && !data.map)\n        throw new Error('WOOT! Illegal object in data : ' + data);\n    }\n\n    return data;\n  }\n\n  function finnerdata(data) {\n    if (typeof data !== 'object' && typeof data !== 'number' && typeof data !== 'string')\n      throw new Error('WOOT! Data is not an object/string/number : ' + data);\n\n    if (data || data === 0) {\n      if (typeof data === 'number')\n        data = String(data);\n\n      else if (data.length && data.map)\n        data = data.map(finnerdata);\n\n      else if (typeof data === 'object' && !data.map)\n        throw new Error('WOOT! Illegal object in data : ' + data);\n    }\n\n    return data;\n  }\n\n\n  // Prepare command.\n\n  function prep(command, args, callback) {\n    args = args.map(function(arg) { return String(arg); });\n    command = command.toUpperCase();\n    var block = false;\n    if (/^B[LR]POP/.test(command) && args.length)   //  Backend will validate the timeout param more robustly.\n      block = parseInt(args[args.length - 1], 10) || true;\n\n    if (!backend[command])\n      throw new Error(\"fakeredis: \" + command + \" is not implemented in fakeredis. Let me know if you need it.\");\n\n    return { command: command, args: args, callback: callback, block: block };\n  }\n\n\n  // Helper to push replies onto the replies list.\n\n  function pushReply(err, data) {\n    /*jshint validthis:true*/\n    this.push(err ||fdata(data));\n  }\n\n\n  // Immitate latency.\n\n  minLatency = Math.ceil(minLatency || 15);\n  maxLatency = Math.ceil(maxLatency || minLatency * 3);\n\n  if (maxLatency < minLatency || minLatency < 0)\n    throw new Error(\"Bad min/max latency settings.\");\n\n  function randLat() {\n    return Math.ceil((maxLatency - minLatency)* Math.random() + minLatency);\n  }\n\n};\n\n\nfunction Delay(object, method, delay) {\n  var queue\n    , flush;\n\n  this[method] = function() {\n    if (!queue) {\n      queue = [arguments];\n      setTimeout(flush, delay);\n    }\n    else\n      queue.push(arguments);\n  };\n\n  flush = function() {\n    var q = queue, i, n = q.length;\n    queue = null;\n\n    for (i = 0; i < n; i++)\n      object[method].apply(object, q[i]);\n  };\n\n}\n\n\n","/home/travis/build/npmtest/node-npmtest-fakeredis/node_modules/fakeredis/lib/helpers.js":"\"use strict\";\n\n\n// Stylize a string alla vows\n\nvar stylize;\n(function() {\n  var styles = {\n    bold: '1'\n  , italic: '3'\n  , underline: '4'\n  , grey: '90'\n  , red: '1;31'\n  , green: '1;32'\n  , yellow: '1;33'\n  , blue: '1;34'\n  , magenta: '1;35'\n  , cyan: '1;36'\n  , white: '1;37'\n  };\n\n  stylize = function(str, style) {\n    return '\\x1B[' + styles[style] + 'm' + str + '\\x1B[0m';\n  };\n}\n());\n\n\n// Prettyprint a subset of the keyspace of the fakeredis instance.\n\nexports.pretty = function(options) {\n  var pattern, wrap, label;\n\n  if (typeof options === 'string')\n    options = { pattern: options };\n\n  pattern = (options && options.pattern) || \"*\";\n  wrap = (options && options.wrap) || 4;\n  label = (options && options.label) || \"keyspace \" + pattern;\n\n  this.send_command(\"FAKE_DUMP\", [pattern || \"*\"], function(err, dump) {\n    var i, n = dump && dump.length, style, key, ttl, type, value;\n\n    if (err)\n      throw err;\n    if (label)\n      process.stdout.write('\\n' + stylize(label, 'bold') + ':\\n\\n');\n    else\n      process.stdout.write('\\n');\n\n    for (i = 0; i < n; i += 4) {\n      key = dump[i];\n      ttl = dump[i + 1];\n      type = dump[i + 2];\n      value = dump[i + 3];\n\n      style = 'white';\n      if (type === 'list')\n        style = 'green';\n      else if (type === 'hash')\n        style = 'yellow';\n      else if (type === 'set')\n        style = 'cyan';\n      else if (type === 'zset')\n        style = 'red';\n\n      /*jshint loopfunc:true*/\n      process.stdout.write(\n        stylize(type, 'bold') + '\\t' + stylize(key, 'bold') + '\\n' + stylize(ttl, ttl >= 0 ? 'italic' : 'grey') + '\\t' + (\n            value.map\n\n            ? value.map(function(member, index) {\n                /*jshint -W018*/\n                return (wrap && index && !((index) % wrap)? '\\n\\t' : '') + stylize(member, style);\n              })\n              .join(', \\t')\n\n            : stylize(value, style)\n\n          ) + '\\n\\n'\n      );\n    }\n  });\n};\n\n\n// Get a subset of the keyspace of the fakeredis instance.\n\nexports.getKeyspace = function(options, callback) {\n  var cb;\n\n  if (!callback && typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  if (typeof options === 'string')\n    options = { pattern: options };\n  if (!callback || typeof callback !== 'function')\n    throw new Error(\"You didn't provide a valid callback.\");\n\n  // By default respond with an array of [ key, ttl, type, value, key2, ttl2, type2, value2, ... ]\n  cb = callback;\n\n  // Respond with a key-value map.\n  if (options && options.map)\n    cb = function(err, data) {\n      var out, i, n;\n      if (data) {\n        out = {};\n        n = data.length;\n        for (i = 0; i < n; i += 4)\n          out[data[i]] = data[i + 3];\n      }\n\n      callback(err, out);\n    };\n\n  // Respond with an array of arrays.\n  else if (options && options.group)\n    cb = function(err, data) {\n      var out, i, n;\n      if (data) {\n        out = [];\n        n = data.length;\n        for (i = 0; i < n; i += 4)\n          out.push(data.slice(i, 4));\n      }\n\n      callback(err, out);\n    };\n\n  this.send_command(\"FAKE_DUMP\", [options && options.pattern || \"*\"], cb);\n};\n\n\n// Serve getKeyspace() as JSON from localhost:[port]/keyspace.json\n\nexports.serveKeyspace = function(port) {\n  var self = this\n    , url = require(\"url\");\n\n  require(\"http\").createServer(\n    function(req, res) {\n      var data = url.parse(req.url, true);\n\n      if (data.pathname !== '/keyspace.json') {\n        res.statusCode = 404;\n        res.end(\"Not found.\");\n        return;\n      }\n\n      if (req.method !== 'GET') {\n        res.statusCode = 405;\n        res.end(\"Method not supported.\");\n        return;\n      }\n\n      self.getKeyspace(data.query, function(err, data) {\n        if (err) {\n          res.statusCode = 500;\n          res.end(err);\n          return;\n        }\n\n        res.setHeader(\"Content-Type\", \"application/json\");\n        res.end(JSON.stringify(data));\n      });\n    }\n  )\n  .listen(port);\n};\n"}